مصنف: Jaynam، مترجم: AI، تاریخِ تازہ کاری: 27 اگست 2024

## 2. پروگرامنگ پر ایک نظر

کمپیوٹرز کی شاندار دنیا میں خوش آمدید! پروگرامنگ کا کام شروع کرنے سے پہلے، یہ ضروری ہے کہ ہم کمپیوٹرز کے بارے میں مزید معلومات حاصل کریں۔ آئیے کمپیوٹر کے کچھ بنیادی پہلوؤں کو دریافت کریں جو پروگرامنگ سے متعلق ہیں۔

### 2.1 کمپیوٹر کیسے معلومات پروسیس کرتا ہے

**(1) بائنری کوڈ کا تعارف**

کبھی سوچا ہے کہ آپ کا کمپیوٹر، ٹیبلٹ، یا اسمارٹ فون اتنے سارے شاندار کام کیسے کرتا ہے؟ اس سب کا راز ہے کہ وہ معلومات کو کس طرح پروسیس کرتا ہے۔ آئیے اس عمل کی بنیادیات میں جھانکتے ہیں، خاص طور پر "بائنری کوڈ" کے بارے میں۔ پہلے، آئیے سوچتے ہیں کہ ہم اپنے روزمرہ کی زندگی میں معلومات کو کیسے ظاہر کرتے ہیں۔

**ہمارے روزمرہ کی زندگی میں معلومات کو ظاہر کرنے کے طریقے**

ہماری روزمرہ کی زندگی میں، ہم مختلف طریقوں سے معلومات کو ظاہر اور شیئر کرتے ہیں۔ مثال کے طور پر:

- **زبانیں:** چاہے لکھا ہوا ہو یا بولا ہوا، ہم معلومات کو علامتوں کے ذریعے بات چیت اور شیئر کرتے ہیں۔ ہر حرف کی ایک خاص شکل اور معنی ہوتی ہے اور ہر لفظ یا جملہ جو ہم بولتے ہیں اس کا مخصوص مطلب ہوتا ہے۔
- **گرافک علامتیں اور تصویریں:** ٹریفک کے اشارے، ڈرائنگز، اور تصویریں بھی بہت ساری معلومات فراہم کر سکتی ہیں۔
- **آوازیں:** ہم مختلف آوازوں کا استعمال بھی معنی پہنچانے کے لیے کرتے ہیں۔ دروازے کی گھنٹی ہمیں بتا سکتی ہے کہ کوئی آیا ہے۔ سائرن کی آواز ہمیں خبردار کرتی ہے۔

اسی طرح، کمپیوٹروں کو معلومات سمجھنے اور پروسیس کرنے کے لیے ایک خاص نظام کی ضرورت ہوتی ہے۔ یہ نظام بائنری کوڈ ہے، جو صرف دو علامتوں 0 اور 1 پر مشتمل ایک عالمی زبان کی طرح ہے۔ "بائنری" اس "بائنری سسٹم" کی طرف اشارہ کرتا ہے جو صرف دو علامتوں (0 اور 1) کا استعمال کرتا ہے۔ اور "کوڈ" کا مطلب ہے معلومات کو اس طرح کوڈ کرنا، ڈی کوڈ کرنا، یا کمیونیکیٹ کرنا کہ یہ سمجھنے یا استعمال کرنے کے قابل ہو، خاص طور پر کمپیوٹرز اور معلومات کی پروسیسنگ کے تناظر میں۔

**بائنری نظام**

ہماری روزمرہ زندگی میں، ہم عام طور پر 10 ہندسوں پر مبنی نمبر استعمال کرتے ہیں: 0 سے 9 تک۔ آئیے ایک سادہ ریاضی کا کام کریں۔ اگر آپ 0 میں 1 شامل کریں، تو نتیجہ 1 ہوتا ہے۔ پھر ایک بار پھر 1 شامل کریں، تو آپ کو 2 ملتا ہے۔ اگر ہم 0 میں 1 نو بار شامل کریں تو ہم تمام 10 ہندسے استعمال کر لیتے ہیں۔ لیکن اگر ہم 0 میں 10 بار 1 شامل کریں تو نتیجہ 10 ہوتا ہے۔ "10" پر غور کریں۔ یہ "1" اور "0" پر مشتمل ہے، اور "1" "0" کے بائیں جانب ہے۔ اگر ہم "10" کے دونوں ہندسوں کو جمع کریں تو 1 اور 0 کا مجموعہ 1 ہوگا۔ لیکن یہ سادہ جمع ہمیں نہیں بتاتا کہ '10' ہماری دہائی نظام میں 10 کی قیمت کو کیسے ظاہر کرتا ہے۔

ہماری روزمرہ زندگی میں، جب تک کچھ اور نہ کہا جائے، ہم جو نمبر استعمال کرتے ہیں وہ "دہائی نظام" پر مبنی ہوتے ہیں۔ لفظ "دہائی" لاطینی لفظ "decem" سے آیا ہے جس کا مطلب ہے "دس"۔ "دہائی نظام" ایک نمبر نظام کو ظاہر کرتا ہے جو دس کی طاقتوں پر مبنی ہے۔ دہائی نظام میں، ہر جگہ کی قیمت اس سے دائیں طرف کی جگہ کی قیمت سے دس گنا زیادہ ہوتی ہے۔ ہر ہندسہ ایک مختلف جگہ کی قیمت کو ظاہر کرتا ہے، جو دہائی نظام میں ایک طاقت ہوتی ہے۔

مثال کے طور پر، نمبر 345 کو دیکھیں:

- ہندسہ 5 "یونٹس" کی جگہ پر ہے (10^0، دس کی صفر کی طاقت)، جو 5 کو ظاہر کرتا ہے۔
- ہندسہ 4 "دسوں" کی جگہ پر ہے (10^1، دس کی پہلی طاقت)، جو 4 × 10 = 40 کو ظاہر کرتا ہے۔
- ہندسہ 3 "سو" کی جگہ پر ہے (10^2، دس کی دوسری طاقت)، جو 3 × 100 = 300 کو ظاہر کرتا ہے۔

ان قیمتوں کو ملانے سے (300 + 40 + 5) ہمیں 345 کا کل قیمت ملتا ہے۔

اب، بائنری نظام کو تلاش کریں۔ دہائی نظام کی طرح، جو دس ہندسے استعمال کرتا ہے، بائنری نظام میں صرف دو ہندسے ہوتے ہیں: 0 اور 1۔ بائنری نمبر میں ہر ہندسہ 2 کی طاقت کو ظاہر کرتا ہے، نہ کہ 10 کی۔

مثال کے طور پر، بائنری نمبر 101 میں:

- سب سے دائیں ہندسہ (1) "ونز" کی جگہ پر ہے (2^0، دو کی صفر کی طاقت)، جو 1 کو ظاہر کرتا ہے۔
- درمیانہ ہندسہ (0) "ٹوز" کی جگہ پر ہے (2^1، دو کی پہلی طاقت)، جو 0 × 2 = 0 کو ظاہر کرتا ہے۔
- سب سے بایاں ہندسہ (1) "فورز" کی جگہ پر ہے (2^2، دو کی دوسری طاقت)، جو 1 × 4 = 4 کو ظاہر کرتا ہے۔

بائنری نمبر 101 کی دہائی قیمت معلوم کرنے کے لیے، ان قیمتوں کو ملا لیں: 4 ("فورز" کی جگہ سے) + 0 ("ٹوز" کی جگہ سے) + 1 ("ونز" کی جگہ سے) = 5۔

لہذا، بائنری نمبر 101 دہائی نمبر 5 کے برابر ہے۔

**کمپیوٹرز بائنری سسٹم کیوں استعمال کرتے ہیں**

اعشاری نظام سب سے زیادہ استعمال ہونے والا عددی نظام ہے اور یہ روزمرہ کی گنتی اور حساب کتاب میں استعمال ہوتا ہے۔ انسانوں کی دس انگلیاں ہیں، جو اعشاری نظام میں گنتی کو قدرتی اور سادہ بناتی ہیں۔ یہ قدرتی گنتی کا طریقہ اعشاری نظام کی ترقی پر اثرانداز ہوا۔ جبکہ اعشاری نظام ہمارے لیے سادہ اور آسان ہے، یہ کمپیوٹروں کے لیے بہترین انتخاب نہیں ہے۔ اس کے بجائے، بائنری نظام ایسی الیکٹرانک مشینوں کے لیے زیادہ موزوں ہے۔ اس کی وجہ کمپیوٹروں کی "ساخت" میں ہے۔

کمپیوٹرز برقی سرکٹس کا استعمال کرتے ہیں جو یا تو آن یا آف ہو سکتے ہیں۔ یہ دونوں حالتیں بائنری ڈیجیٹس 0 اور 1 سے قدرتی طور پر نمائندگی کی جاتی ہیں۔ بائنری کمپیوٹروں کے لیے مثالی ہے کیونکہ یہ ان کی آن/آف برقی سگنلز سے بالکل ہم آہنگ ہے۔ بائنری کا استعمال کرکے، کمپیوٹرز مؤثر طریقے سے ڈیٹا کو پروسیس اور اسٹور کر سکتے ہیں۔

سی پی یو، جو کمپیوٹر کا ایک اہم حصہ ہے، ٹرانزسٹروں پر انحصار کرتا ہے جو بنیادی اکائیوں کے طور پر کام کرتے ہیں۔ ایک ٹرانزسٹر ایک بہت ہی چھوٹا اور سادہ سرکٹ عنصر ہے، جو الیکٹرانک آن/آف سوئچز کے طور پر کام کر سکتا ہے اور کمزور برقی سگنلز کو بڑھا سکتا ہے۔ جدید سی پی یوز میں اربوں ٹرانزسٹروں ہوتے ہیں، جو ڈیٹا پروسیسنگ اور اسٹوریج کے لیے آن/آف سوئچز کے طور پر کام کرتے ہیں۔ اسی طرح، رام، جی پی یوز اور ایس ایس ڈی (سالیڈ اسٹیٹ ڈرائیو) بھی ٹرانزسٹروں کا استعمال کرتے ہیں۔

کمپیوٹر میں، تقریباً تمام ٹرانزسٹروں کا کام آن/آف سوئچز کے طور پر ہوتا ہے، جس کا مطلب ہے کہ وہ صرف دو حالتوں میں کام کرتے ہیں: آن اور آف۔ اس لیے 1 کو "آن" حالت کے لیے اور 0 کو "آف" حالت کے لیے استعمال کرنا قدرتی اور سادہ ہے۔

**(2) بائنری کوڈ ڈیٹا کی نمائندگی کیسے کرتا ہے**

یہ سمجھنے کے لیے کہ بائنری کوڈ ڈیٹا کی نمائندگی کیسے کرتا ہے، پہلے ہم دیکھتے ہیں کہ پی سی معلومات کو کیسے پروسیس اور اسٹور کرتا ہے۔ جب کوئی پروگرام چل رہا ہوتا ہے، تو اس کی ہدایات کا سلسلہ رام میں لوڈ کیا جاتا ہے۔ دوسرے پروگراموں کی ہدایات کے ساتھ، یہ عملدرآمد کے لیے قطار میں لگا دی جاتی ہیں۔ سی پی یو مسلسل اس قطار سے ہدایات کو ایک وقت میں ایک ایک کر کے لیتی ہے۔ ہر بار جب سی پی یو ایک ہدایت لیتی ہے، تو یہ رام سے پڑھتی ہے، اور کبھی کبھار ہدایت میں ہارڈ ڈرائیو سے پڑھنا یا لکھنا شامل ہوتا ہے۔ جدید سی پی یوز ایک وقت میں 64 بٹس تک ڈیٹا پروسیس کر سکتے ہیں، جبکہ پرانے سی پی یوز صرف 32 بٹس تک پروسیس کر سکتے ہیں۔

یہ چند سوالات پیدا کرتا ہے: کمپیوٹر کو رام سے کتنے بٹس کا ڈیٹا ایک وقت میں پڑھنا یا لکھنا چاہیے؟ بنیادی اکائی کے طور پر کتنے بٹس کا استعمال کرنا چاہیے؟ اگر سی پی یو ایک وقت میں صرف 1 بٹ ہی پڑھتا یا لکھتا، تو یہ انتہائی غیر مؤثر اور وقت طلب ہوتا کیونکہ بار بار عمل درآمد کی ضرورت ہوتی۔ لہذا، ایک 64-بٹ سی پی یو عام طور پر ایک بار میں 64 بٹس کا ڈیٹا پڑھتا یا لکھتا ہے، اور 32-بٹ سی پی یو 32 بٹس پروسیس کرتا ہے تاکہ کارکردگی اور مؤثریت کا توازن برقرار رہے۔ رام عام طور پر 8 بٹس کو اس کی بنیادی اکائی کے طور پر استعمال کرتا ہے۔

رام کے لیے 8-بٹ اکائی کا انتخاب تاریخی، تکنیکی، اور معیاری عوامل سے متاثر ہے۔ ابتدائی کمپیوٹر مختلف ڈیٹا اکائیوں کے سائز استعمال کرتے تھے، لیکن جیسے جیسے ٹیکنالوجی ترقی کرتی گئی، 8-بٹ اکائی زیادہ عام ہوگئی۔ یہ سائز کارکردگی اور صلاحیت کے درمیان توازن قائم کرنے کے لیے خاص طور پر موزوں ہے، خاص طور پر کرداروں اور ڈیٹا کی نمائندگی کے لیے۔

**ASCII Code**

ASCII (American Standard Code for Information Interchange) ایک کردار کوڈنگ اسٹینڈرڈ ہے جو کمپیوٹرز اور دیگر متن پر مبنی ڈیوائسز میں مواد کی نمائندگی کے لیے استعمال ہوتا ہے۔ یہ جدید کوڈنگ اسکیموں کے لیے بنیادی ہے۔ ASCII ایک 7-bit بائنری نمبر کا استعمال کرتا ہے، جس کی وجہ سے 128 منفرد کرداروں کی نمائندگی ممکن ہے، جس کے کوڈز 0 سے 127 تک ہوتے ہیں۔

معیاری ASCII کردار شامل ہیں:

- کنٹرول کردار (0–31):

  یہ ناقابل پرنٹ کردار ہیں جو ٹیکسٹ پروسیسنگ کو کنٹرول کرتے ہیں۔ مثالیں شامل ہیں:

  - `0` (NUL): نل کردار
  - `9` (TAB): افقی ٹیب
  - `10` (LF): لائن فیڈ (نیا لائن)
  - `13` (CR): کیریج ریٹرن

- پرنٹ ایبل کردار (32–127):

  یہ قابل دیکھنے والے کردار ہیں جیسے حروف، اعداد، نشانات، اور علامتیں۔ مثالیں شامل ہیں:

  - `32` (SPACE): اسپیس کردار
  - `65` (A): بڑے حرف A
  - `97` (a): چھوٹے حرف a
  - `48` (0): عدد 0
  - `33` (!): حیرت کا نشان

ASCII کوڈز 7 بٹس کا استعمال کرتے ہیں، جو 128 کرداروں کی نمائندگی کر سکتے ہیں، لیکن جدید کمپیوٹر 8 بٹس کو بنیادی ڈیٹا یونٹ کے طور پر استعمال کرتے ہیں۔ یہ 8-بٹ یونٹ، یا بائٹ، 256 کرداروں کی نمائندگی کی اجازت دیتا ہے، جو عموماً انگریزی اور دیگر مغربی زبانوں کے لیے کافی ہے۔ پیچیدہ زبانوں کے لیے اضافی بائٹس استعمال کی جاتی ہیں تاکہ کرداروں کی نمائندگی کی جا سکے، اس بات کو یقینی بناتے ہوئے کہ میموری اور اسٹوریج کا مؤثر استعمال ہو۔ اگرچہ ASCII خود 7 بٹس کی ضرورت ہوتی ہے، 8-بٹ کی نمائندگی کمپیوٹروں میں عام ہے، اضافی بٹ عام طور پر صفر پر سیٹ ہوتا ہے۔ مثال کے طور پر، بڑے حرف "A" کے لیے ASCII کوڈ 65 (ڈیسمل) یا 01000001 (بائنری) ہے، اضافی بٹ صفر ہے۔

**کمپیوٹر میں کچھ ریاضیاتی علامات**

معیاری کی بورڈ پر، آپ شاید کچھ ریاضیاتی علامات کی عدم موجودگی محسوس کریں گے، جیسے ضرب کی علامت (×)۔ اس کے بجائے، کمپیوٹر اکثر سادگی کے لیے متبادل علامات استعمال کرتے ہیں۔ یہاں کچھ عام مثالیں ہیں:

- ضرب: `*`
- تقسیم: `/`
- ماڈیولو (تقسیم کا باقی ماندہ): `%`
- قوت: `**` (زیادہ تر پروگرامنگ زبانوں جیسے Python میں استعمال ہوتا ہے)، اور کچھ معاملات میں، `^` (عام طور پر کیلکولیٹرز میں استعمال ہوتا ہے)۔

یہ علامات مختلف پروگرامنگ ماحول اور کیلکولیٹرز میں حسابی کارروائیوں کو انجام دینے کے لیے استعمال ہوتی ہیں۔

**ڈیٹا کے حجم کی اکائیاں**

جدید کمپیوٹر 8 بٹس کو بنیادی ڈیٹا اکائی کے طور پر استعمال کرتے ہیں، جسے بائٹ (B) کہا جاتا ہے۔ یہاں دیگر عام ڈیٹا حجم کی اکائیوں اور ان کے تبادلوں پر نظر ڈالتے ہیں:

- بٹ (b، چھوٹے حرف میں): کمپیوٹنگ میں سب سے چھوٹا ڈیٹا یونٹ۔ یہ ایک بائنری ڈیجیٹ کو ظاہر کرتا ہے، جو کہ `0` یا `1` ہو سکتا ہے۔
- بائٹ (B، بڑے حرف میں): بنیادی ڈیٹا حجم کی اکائی، جو 8 بٹس پر مشتمل ہوتی ہے۔

زیادہ بڑے پیمانے کی اکائیاں دو مختلف تبادلوں پر منحصر ہوتی ہیں: بائنری اور ڈیسیمل۔ بائنری اکائیاں 2 کی طاقتوں پر مبنی ہیں، جبکہ ڈیسیمل اکائیاں 10 کی طاقتوں کا استعمال کرتی ہیں۔ کمپیوٹنگ میں، بائنری اکائیاں معیاری ہوتی ہیں، جبکہ مارکیٹنگ میں ڈیسیمل اکائیاں اکثر استعمال ہوتی ہیں۔ بائٹ سے شروع کرتے ہوئے، ایک بڑا بائنری بنیاد والا یونٹ پہلے چھوٹے یونٹ سے 2^10 (1024) گنا ہوتا ہے جبکہ ایک بڑا ڈیسیمل بنیاد والا یونٹ پہلے چھوٹے یونٹ سے 10^3 (1000) گنا ہوتا ہے۔

بائنری بنیاد پر اکائیاں:

- کلو بائٹ (KB): 1 KB = 1,024 بائٹس (2^10 بائٹس)۔
- میگا بائٹ (MB): 1 MB = 1,024 KB = 1,048,576 بائٹس (2^20 بائٹس)۔
- گیگا بائٹ (GB): 1 GB = 1,024 MB = 1,073,741,824 بائٹس (2^30 بائٹس)۔
- ٹیرا بائٹ (TB): 1 TB = 1,024 GB = 1,099,511,627,776 بائٹس (2^40 بائٹس)۔

ڈیسیمل بنیاد پر اکائیاں:

- کلو بائٹ (KB): 1 KB = 1,000 بائٹس (10^3 بائٹس)۔
- میگا بائٹ (MB): 1 MB = 1,000 KB = 1,000,000 بائٹس (10^6 بائٹس)۔
- گیگا بائٹ (GB): 1 GB = 1,000 MB = 1,000,000,000 بائٹس (10^9 بائٹس)۔
- ٹیرا بائٹ (TB): 1 TB = 1,000 GB = 1,000,000,000,000 بائٹس (10^12 بائٹس)۔

بائنری بنیاد پر پیمائش کو واضح طور پر ممتاز کرنے کے لیے، IEC (بین الاقوامی برقیاتی کمیٹی) نے "بی" پیش لفظ متعارف کروایا، جو کہ "بائنری" کے لیے مختصر ہے۔ یہ اکائیاں بائنری تبادلوں کی طرح ہی ہوتی ہیں، مگر ان کے نام زیادہ قابل شناخت ہوتے ہیں۔

- کبی بائٹ (KiB): 1 KiB = 1,024 بائٹس (2^10 بائٹس)۔
- میبی بائٹ (MiB): 1 MiB = 1,024 KiB = 1,048,576 بائٹس (2^20 بائٹس)۔
- گیبی بائٹ (GiB): 1 GiB = 1,024 MiB = 1,073,741,824 بائٹس (2^30 بائٹس)۔
- ٹیبی بائٹ (TiB): 1 TiB = 1,024 GiB = 1,099,511,627,776 بائٹس (2^40 بائٹس)۔

ڈیسیمل تبادلوں کا اکثر مارکیٹنگ میں استعمال ہوتا ہے کیونکہ یہ ایک ہی ذخیرہ کی صلاحیت کے لیے بڑے نمبر تیار کرتا ہے۔ مثال کے طور پر، ایک ہارڈ ڈرائیو جس کا لیبل 500 GB (ڈیسیمل) کے طور پر ہے، دراصل 500,000,000,000 بائٹس ہے، جو کہ تقریباً 465 GiB (بائنری) کے برابر ہے۔

**مختلف ڈیٹا اقسام کے لئے بائنری نمائندگی**

تمام ڈیٹا، چاہے اس کی نوعیت کوئی بھی ہو، آخرکار بائنری شکل میں نمائندہ ہوتا ہے۔ کمپیوٹرز میں ڈیٹا 0 اور 1 کی سیریز کے طور پر پروسیس اور اسٹور کیا جاتا ہے۔ متن، امیج، آڈیو یا کسی اور قسم کے ڈیٹا کو اسٹور کرنے کے لئے ہمیں ان کو "ترجمہ" کر کے بائنری کوڈ میں تبدیل کرنا پڑتا ہے، جسے "انکوڈنگ" کہا جاتا ہے۔ جب ہمیں ان ڈیٹا کا انسانی دوستانہ طریقے سے استعمال کرنا ہوتا ہے، تو سافٹ ویئر بائنری کوڈ کو تفسیری طور پر تبدیل کرتا ہے تاکہ ہم اسے سمجھ سکیں، جسے "ڈیکوڈنگ" کہا جاتا ہے۔

یہاں مختلف ڈیٹا اقسام کو انکوڈ کرنے کی مثالیں دی گئی ہیں:

- **متن**: کرداروں کو ASCII یا یونی کوڈ جیسے انکوڈنگ اسٹینڈرڈز کے ذریعہ نمائندہ کیا جاتا ہے۔ ہر کردار کو ایک منفرد بائنری کوڈ تفویض کیا جاتا ہے۔ مثال کے طور پر، 'A' کا ASCII کوڈ بائنری میں 01000001 ہے۔
- **اعداد**: اعداد مختلف بائنری فارمیٹس میں نمائندہ ہوتے ہیں، جیسے کہ انٹیجرز (اعداد جو کسری حصے کے بغیر ہوتے ہیں، جیسے `-3`, `0`) اور فلوٹنگ پوائنٹ نمبرز (اعداد جو کسری حصے کے ساتھ ہوتے ہیں، جیسے `3.14`, `-0.01`)۔ مثال کے طور پر، انٹیجر 5 کو 8-بٹ بائنری نمائندگی میں 00000101 کے طور پر ظاہر کیا جاتا ہے۔
- **آڈیو**: آڈیو ڈیٹا عام طور پر نمونوں کی ایک سیریز کے طور پر نمائندہ ہوتا ہے۔ یہ نمونے باقاعدہ وقفوں پر قبضہ کیے جاتے ہیں اور بائنری میں انکوڈ کیے جاتے ہیں۔ مثال کے طور پر، 16-بٹ آڈیو نمونہ ممکنہ طور پر 16-بٹ بائنری نمبر کے طور پر نمائندہ ہوتا ہے۔
- **تصاویر**: تصاویر پکسلز پر مشتمل ہوتی ہیں، ہر ایک کا رنگی قدر ہوتا ہے۔ ایک گرے اسکیل تصویر میں، ہر پکسل کو اس کی شدت کو ظاہر کرنے کے لئے 8-بٹ بائنری نمبر کے طور پر نمائندہ کیا جا سکتا ہے۔ رنگین تصویر میں، ہر پکسل عموماً بائنری نمبروں کے مجموعے سے نمائندہ ہوتا ہے جو اس کے سرخ، سبز، اور نیلے رنگ کے اجزاء کو ظاہر کرتا ہے۔
- **ویڈیو**: ویڈیو ایک تصویر کی سیریز (فریمز) پر مشتمل ہوتی ہے اور اکثر آڈیو بھی شامل ہوتی ہے۔ ہر فریم ایک تصویر ہوتی ہے جو بائنری میں نمائندہ ہوتی ہے، اور فریمز تیزی سے دکھائے جاتے ہیں تاکہ حرکت کا تاثر پیدا ہو سکے۔
- **فائلیں اور فارمیٹس**: مختلف فائل فارمیٹس (جیسے JPEG تصاویر کے لئے، MP3 آڈیو کے لئے، MP4 ویڈیو کے لئے) مخصوص طریقے سے ڈیٹا کو انکوڈ کرنے کے طریقے کو بیان کرتے ہیں۔ یہ فارمیٹس بائنری کوڈ کا استعمال کرتے ہیں تاکہ ڈیٹا کو موثر طریقے سے ترتیب اور کمپریس کیا جا سکے۔

**ڈیٹا کمپریشن**

تصور کریں کہ آپ کے پاس کھلونے کا ایک بڑا ڈھیر ہے جسے آپ کو ایک چھوٹے سے ڈبے میں پیک کرنا ہے۔ ڈیٹا کمپریشن بالکل ایسے ہی ہے جیسے کھلونوں کو ترتیب دے کر اور سکڑ کر ڈبے میں فٹ کرنا تاکہ سب کھلونے بغیر کسی نقصان کے جگہ میں آجائیں۔ کمپیوٹرز میں، یہ فائلز کو چھوٹا کرنے کے بارے میں ہے تاکہ وہ کم جگہ لیں اور بھیجنے یا اسٹور کرنے میں تیز ہوں۔

یہاں ایک سادہ مثال ہے رن-لینتھ انکوڈنگ (RLE) الگورڈم کی: اگر آپ کے پاس انگریزی حروف کا ایک سلسلہ "AAAAAAADDDDCCVSSSSSSSSS" ہے، جو کہ 23 حروف پر مشتمل ہے اور 23 بائٹس کی جگہ لیتی ہے۔ ہم دیکھ سکتے ہیں کہ ہر حرف کتنی بار دہرایا جاتا ہے اور ان حروف کو گنتی اور حرف خود کے ساتھ بدل دیتے ہیں: "7A4D2C1V9S"۔ نیا سلسلہ 5 گنتیوں اور 5 حروف پر مشتمل ہے۔ ہم ہر گنتی کو ایک بائٹ میں نمائندگی کر سکتے ہیں اور حروف کے لئے ASCII کوڈ استعمال کر سکتے ہیں، جس سے کل 10 بائٹس بنتی ہیں۔ جب ہمیں سلسلہ کو decompress کرنا ہوتا ہے، تو ہم ایک گنتی اور حرف پڑھتے ہیں، پھر حرف کو گنتی کے مطابق دہرایا جاتا ہے۔ اس طرح، ہم ڈیٹا کے حجم کو کم کرتے ہیں اور کم جگہ استعمال کرتے ہیں۔

مختلف ڈیٹا کی اقسام کے لیے ہم عموماً مختلف کمپریشن الگورڈمز کا انتخاب کرتے ہیں کیونکہ ہر ایک کے اپنے فوائد اور حدود ہوتی ہیں۔